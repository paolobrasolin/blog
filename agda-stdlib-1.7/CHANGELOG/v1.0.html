<!DOCTYPE html>
<html lang="en-US">
  <head>
    
      <script async src="https://www.googletagmanager.com/gtag/js?id=UA-34703595-2"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-34703595-2');
      </script>
    
    <meta charset="UTF-8">
    <!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Version 1.0 | Paolo Brasolin</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="Version 1.0" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="This is where i jot down stuff. I am Paolo Brasolin." />
<meta property="og:description" content="This is where i jot down stuff. I am Paolo Brasolin." />
<link rel="canonical" href="https://paolobrasolin.github.io//agda-stdlib-1.7/CHANGELOG/v1.0.html" />
<meta property="og:url" content="https://paolobrasolin.github.io//agda-stdlib-1.7/CHANGELOG/v1.0.html" />
<meta property="og:site_name" content="Paolo Brasolin" />
<script type="application/ld+json">
{"description":"This is where i jot down stuff. I am Paolo Brasolin.","url":"https://paolobrasolin.github.io//agda-stdlib-1.7/CHANGELOG/v1.0.html","@type":"WebPage","headline":"Version 1.0","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#157878">
    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <link rel="stylesheet" href="/lagda/Agda.css?v=">

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
    <!-- The loading of KaTeX is deferred to speed up page rendering -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script>
    <!-- To automatically render math in text elements, include the auto-render extension: -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"
        onload="renderMathInElement(document.body,{macros:{ '':'', },delimiters:[{left:'$$',right:'$$',display:true},{left:'$',right:'$',display:false}]});"></script>

  </head>

  <body>
    <header id="header">
      <nav>
        <a href="/">Back to index.</a>
        <a href="#footer">What's this?</a>
      </nav>
    </header>

    <main>
      <article>
    <p>The library has been tested using Agda version 2.6.0.</p>

<p>Important changes since 0.17:</p>

<h2 id="highlights">Highlights</h2>

<ul>
  <li>
    <p>The library has been refactored to make clear where axiom K is used and
where it is not. Hence it can now be used in conjunction with the
<code class="language-plaintext highlighter-rouge">--without-k</code> option.</p>
  </li>
  <li>
    <p>Equational and inequality reasoning has been revamped. Several new
primitives have been added and the inequality reasoning modules can now
prove equalities and strict inequalities in addition to basic inequalities.</p>
  </li>
  <li>
    <p>AVL trees now work with arbitrary equalities rather than only propositional
equality.</p>
  </li>
  <li>
    <p>New top level <code class="language-plaintext highlighter-rouge">Axiom</code> directory which contains statements of various
additional axioms such as excluded middle and function extensionality which
users may want to postulate.</p>
  </li>
  <li>
    <p>The proofs <code class="language-plaintext highlighter-rouge">_≟_</code> of decidable equality for <code class="language-plaintext highlighter-rouge">String</code>s and <code class="language-plaintext highlighter-rouge">Char</code>s have been
made safe.</p>
  </li>
</ul>

<h2 id="new-modules">New modules</h2>

<ul>
  <li>The following list contains all the new modules that have been added in v1.0:
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Algebra.Construct.NaturalChoice.Min
Algebra.Construct.NaturalChoice.Max
Algebra.Properties.Semilattice
Algebra.FunctionProperties.Consequences.Propositional

Axiom.UniquenessOfIdentityProofs
Axiom.UniquenessOfIdentityProofs.WithK
Axiom.ExcludedMiddle
Axiom.DoubleNegationElimination
Axiom.Extensionality.Propositional
Axiom.Extensionality.Heterogeneous

Codata.Cowriter
Codata.M.Properties
Codata.M.Bisimilarity

Data.Container.Combinator.Properties
Data.Container.Membership
Data.Container.Morphism
Data.Container.Morphism.Properties
Data.Container.Properties
Data.Container.Related
Data.Container.Relation.Unary.All
Data.Container.Relation.Unary.Any
Data.Container.Relation.Unary.Any.Properties
Data.Container.Relation.Binary.Equality.Setoid
Data.Container.Relation.Binary.Pointwise
Data.Container.Relation.Binary.Pointwise.Properties

Data.Char.Properties

Data.Integer.Divisibility.Properties
Data.Integer.Divisibility.Signed
Data.Integer.DivMod

Data.List.Relation.Unary.First
Data.List.Relation.Unary.First.Properties

Data.List.Relation.Binary.Suffix.Heterogeneous
Data.List.Relation.Binary.Suffix.Heterogeneous.Properties
Data.List.Relation.Binary.Prefix.Heterogeneous
Data.List.Relation.Binary.Prefix.Heterogeneous.Properties
Data.List.Relation.Binary.Sublist.Heterogeneous
Data.List.Relation.Binary.Sublist.Heterogeneous.Properties
Data.List.Relation.Binary.Sublist.Heterogeneous.Solver
Data.List.Relation.Binary.Sublist.Setoid
Data.List.Relation.Binary.Sublist.Setoid.Properties
Data.List.Relation.Binary.Sublist.DecSetoid
Data.List.Relation.Binary.Sublist.DecSetoid.Solver
Data.List.Relation.Binary.Sublist.Propositional
Data.List.Relation.Binary.Sublist.Propositional.Properties
Data.List.Relation.Binary.Sublist.DecPropositional
Data.List.Relation.Binary.Sublist.DecPropositional.Solver
Data.List.Relation.Ternary.Interleaving.Setoid
Data.List.Relation.Ternary.Interleaving.Setoid.Properties
Data.List.Relation.Ternary.Interleaving.Propositional
Data.List.Relation.Ternary.Interleaving.Propositional.Properties

Data.Maybe.Relation.Unary.All.Properties

Data.String.Properties

Data.These.Properties

Data.Vec.Any.Properties
Data.Vec.Membership.Setoid
Data.Vec.Membership.DecSetoid
Data.Vec.Membership.DecPropositional
Data.Vec.Relation.Unary.Any.Properties

Debug.Trace

Function.Endomophism.Setoid
Function.Endomophism.Propositional
Function.HalfAdjointEquivalence

Relation.Binary.Construct.Add.Extrema.Equality
Relation.Binary.Construct.Add.Extrema.Strict
Relation.Binary.Construct.Add.Extrema.NonStrict
Relation.Binary.Construct.Add.Infimum.Equality
Relation.Binary.Construct.Add.Infimum.Strict
Relation.Binary.Construct.Add.Infimum.NonStrict
Relation.Binary.Construct.Add.Supremum.Equality
Relation.Binary.Construct.Add.Supremum.Strict
Relation.Binary.Construct.Add.Supremum.NonStrict
Relation.Binary.Construct.Add.Point.Equality
Relation.Binary.Construct.Intersection
Relation.Binary.Construct.Union
Relation.Binary.Construct.NaturalOrder.Left
Relation.Binary.Construct.NaturalOrder.Right
Relation.Binary.Properties.BoundedLattice

Relation.Nullary.Construct.Add.Extrema
Relation.Nullary.Construct.Add.Infimum
Relation.Nullary.Construct.Add.Supremum
Relation.Nullary.Construct.Add.Point
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="non-backwards-compatible-changes">Non-backwards compatible changes</h2>

<h4 id="extending-the-relation-hierarchy-for-container-datatypes">Extending the relation hierarchy for container datatypes</h4>

<ul>
  <li>
    <p>This release has added many new relations over <code class="language-plaintext highlighter-rouge">List</code> (e.g. <code class="language-plaintext highlighter-rouge">First</code>,
<code class="language-plaintext highlighter-rouge">Suffix</code>, <code class="language-plaintext highlighter-rouge">Prefix</code>, <code class="language-plaintext highlighter-rouge">Interleaving</code>) and it has become clear that the
current hierarchy for relations in <code class="language-plaintext highlighter-rouge">List</code>,<code class="language-plaintext highlighter-rouge">Product</code>,<code class="language-plaintext highlighter-rouge">Sum</code>, <code class="language-plaintext highlighter-rouge">Table</code>
and <code class="language-plaintext highlighter-rouge">Vec</code>is not deep enough.</p>
  </li>
  <li>
    <p>To address this, the contents of <code class="language-plaintext highlighter-rouge">Data.X.Relation</code> have been moved to
<code class="language-plaintext highlighter-rouge">Data.X.Relation.Binary</code> and new folders <code class="language-plaintext highlighter-rouge">Data.X.Relation.(Unary/Ternary)</code>
have been created. <code class="language-plaintext highlighter-rouge">Data.X.(All/Any)</code> have been moved to
<code class="language-plaintext highlighter-rouge">Data.X.Relation.Unary.(All/Any)</code>.</p>
  </li>
  <li>
    <p>The old modules still exist for backwards compatability but are deprecated.</p>
  </li>
</ul>

<h4 id="support-for---without-k">Support for <code class="language-plaintext highlighter-rouge">--without-K</code></h4>

<ul>
  <li>
    <p>The <code class="language-plaintext highlighter-rouge">--without-K</code> flag has been enabled in as many files as possible. An
attempt has been made to only do this in files that do not depend on
any file in which this flag is not enabled.</p>
  </li>
  <li>Agda uses different rules for the target universe of data types when
the <code class="language-plaintext highlighter-rouge">--without-K</code> flag is used, and because of this a number of type
families now target a possibly larger universe:
    <ul>
      <li>Codata.Delay.Bisimilarity                 : <code class="language-plaintext highlighter-rouge">Bisim</code></li>
      <li>Codata.Musical.Covec                      : <code class="language-plaintext highlighter-rouge">_≈_</code>, <code class="language-plaintext highlighter-rouge">_∈_</code>, <code class="language-plaintext highlighter-rouge">_⊑_</code></li>
      <li>Codata.Stream.Bisimilarity                : <code class="language-plaintext highlighter-rouge">Bisim</code></li>
      <li>Data.List.Relation.Binary.Equality.Setoid : <code class="language-plaintext highlighter-rouge">_≋_</code></li>
      <li>Data.List.Relation.Binary.Lex.NonStrict   : <code class="language-plaintext highlighter-rouge">Lex-&lt;</code>, <code class="language-plaintext highlighter-rouge">Lex-≤</code></li>
      <li>Data.List.Relation.Binary.Lex.Strict      : <code class="language-plaintext highlighter-rouge">Lex-&lt;</code>, <code class="language-plaintext highlighter-rouge">Lex-≤</code></li>
      <li>Data.List.Relation.Binary.Pointwise       : <code class="language-plaintext highlighter-rouge">Pointwise</code></li>
      <li>Data.List.Relation.Unary.All              : <code class="language-plaintext highlighter-rouge">All</code></li>
      <li>Data.Maybe                                : <code class="language-plaintext highlighter-rouge">Is-just</code>, <code class="language-plaintext highlighter-rouge">Is-nothing</code></li>
      <li>Data.Maybe.Relation.Unary.Any             : <code class="language-plaintext highlighter-rouge">Any</code></li>
      <li>Data.Maybe.Relation.Unary.All             : <code class="language-plaintext highlighter-rouge">All</code></li>
      <li>Data.Maybe.Relation.Binary.Pointwise      : <code class="language-plaintext highlighter-rouge">Pointwise</code></li>
    </ul>
  </li>
  <li>Because of this change the texts of some type signatures were changed
(some inferred parts of other type signatures may also have changed):
    <ul>
      <li>Data.List.Relation.Binary.Equality.DecSetoid : <code class="language-plaintext highlighter-rouge">≋-decSetoid</code></li>
      <li>Data.Maybe.Relation.Binary.Pointwise         : <code class="language-plaintext highlighter-rouge">setoid</code>, <code class="language-plaintext highlighter-rouge">decSetoid</code></li>
    </ul>
  </li>
  <li>Some code that relies on the K rule or uses heterogeneous equality has
been moved from the existing file <code class="language-plaintext highlighter-rouge">X</code> to a new file <code class="language-plaintext highlighter-rouge">X.WithK</code> file
(e.g. from <code class="language-plaintext highlighter-rouge">Data.AVL.Indexed</code> to <code class="language-plaintext highlighter-rouge">Data.AVL.Indexed.WithK</code>). These are as follows:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Data.AVL.Indexed</code>                                                 : <code class="language-plaintext highlighter-rouge">node-injective-bal, node-injectiveʳ, node-injectiveˡ</code></li>
      <li><code class="language-plaintext highlighter-rouge">Data.Container.Indexed</code>                                           : <code class="language-plaintext highlighter-rouge">Eq, Map.composition, Map.identity, PlainMorphism.NT, PlainMorphism.Natural, PlainMorphism.complete, PlainMorphism.natural, PlainMorphism.∘-correct, setoid, _∈_</code></li>
      <li><code class="language-plaintext highlighter-rouge">Data.Product.Properties</code>                                          : <code class="language-plaintext highlighter-rouge">,-injectiveʳ</code></li>
      <li><code class="language-plaintext highlighter-rouge">Data.Product.Relation.Binary.Pointwise.Dependent</code>                 : <code class="language-plaintext highlighter-rouge">Pointwise-≡⇒≡, ≡⇒Pointwise-≡, inverse, ↣</code></li>
      <li><code class="language-plaintext highlighter-rouge">Data.Vec.Properties</code>                                              : <code class="language-plaintext highlighter-rouge">++-assoc, []=-irrelevance, foldl-cong, foldr-cong</code></li>
      <li><code class="language-plaintext highlighter-rouge">Data.Vec.Relation.Binary.Equality.Propositional</code>                  : <code class="language-plaintext highlighter-rouge">≋⇒≅</code></li>
      <li><code class="language-plaintext highlighter-rouge">Data.W</code>                                                           : <code class="language-plaintext highlighter-rouge">sup-injective₂</code></li>
      <li><code class="language-plaintext highlighter-rouge">Relation.Binary.Construct.Closure.Transitive</code>                     : <code class="language-plaintext highlighter-rouge">∼⁺⟨⟩-injectiveʳ, ∼⁺⟨⟩-injectiveˡ</code></li>
      <li><code class="language-plaintext highlighter-rouge">Relation.Binary.Construct.Closure.ReflexiveTransitive.Properties</code> : <code class="language-plaintext highlighter-rouge">◅-injectiveʳ, ◅-injectiveˡ</code></li>
      <li><code class="language-plaintext highlighter-rouge">Relation.Binary.PropositionalEquality</code>                            : <code class="language-plaintext highlighter-rouge">≡-irrelevance</code>
(The name <code class="language-plaintext highlighter-rouge">↣</code> in <code class="language-plaintext highlighter-rouge">Data.Product.Relation.Binary.Pointwise.Dependent</code> now refers to a new
definition with another type signature.)</li>
    </ul>
  </li>
  <li>Other code has been changed to avoid use of the K rule. As part of
such changes the texts of the following type signatures have been
changed:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Data.AVL.Indexed</code>                                           : <code class="language-plaintext highlighter-rouge">node-injective-key</code></li>
      <li><code class="language-plaintext highlighter-rouge">Data.List.Relation.Binary.Sublist.Propositional.Properties</code> : <code class="language-plaintext highlighter-rouge">∷⁻</code></li>
      <li><code class="language-plaintext highlighter-rouge">Data.Product.Relation.Binary.Pointwise.Dependent</code>           : <code class="language-plaintext highlighter-rouge">↣</code></li>
      <li><code class="language-plaintext highlighter-rouge">Relation.Binary.PropositionalEquality</code>                      : <code class="language-plaintext highlighter-rouge">≡-≟-identity</code>
(The old definition of <code class="language-plaintext highlighter-rouge">↣</code> was moved to <code class="language-plaintext highlighter-rouge">Data.Product.Relation.Binary.Pointwise.Dependent.WithK</code>.)</li>
    </ul>
  </li>
  <li>
    <p>The definition <code class="language-plaintext highlighter-rouge">_≅⟨_⟩_</code> has been removed from <code class="language-plaintext highlighter-rouge">Relation.Binary.PropositionalEquality</code>.</p>
  </li>
  <li>The following previously deprecated names have also been removed:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Data.Product.Relation.Binary.Pointwise.Dependent</code> : <code class="language-plaintext highlighter-rouge">Rel↔≡</code></li>
      <li><code class="language-plaintext highlighter-rouge">Data.Vec.Properties</code>                              : <code class="language-plaintext highlighter-rouge">proof-irrelevance-[]=</code></li>
      <li><code class="language-plaintext highlighter-rouge">Relation.Binary.PropositionalEquality</code>            : <code class="language-plaintext highlighter-rouge">proof-irrelevance</code></li>
    </ul>
  </li>
</ul>

<h4 id="changes-to-the-algebra-hierarchy">Changes to the algebra hierarchy</h4>

<ul>
  <li>
    <p>Over time the algebra inheritance hierarchy has become a tangled
due to poorly structured additions. The following changes attempt
to straighten the hierarchy out and new policies have been put in
place so that the  need for additional such changes will be minimised
in the future.</p>
  </li>
  <li>
    <p>Added <code class="language-plaintext highlighter-rouge">Magma</code> and <code class="language-plaintext highlighter-rouge">IsMagma</code> to the algebra hierarchy.</p>
  </li>
  <li>
    <p>The name <code class="language-plaintext highlighter-rouge">RawSemigroup</code> in <code class="language-plaintext highlighter-rouge">Algebra</code> has been deprecated in favour
of <code class="language-plaintext highlighter-rouge">RawMagma</code>.</p>
  </li>
  <li>
    <p>The fields <code class="language-plaintext highlighter-rouge">isEquivalence</code> and <code class="language-plaintext highlighter-rouge">∙-cong</code> in <code class="language-plaintext highlighter-rouge">IsSemigroup</code> have been
replaced with <code class="language-plaintext highlighter-rouge">isMagma</code>.</p>
  </li>
  <li>
    <p>The field <code class="language-plaintext highlighter-rouge">∙-cong</code> in <code class="language-plaintext highlighter-rouge">IsSemilattice</code>/<code class="language-plaintext highlighter-rouge">Semilattice</code> has been renamed
<code class="language-plaintext highlighter-rouge">∧-cong</code>.</p>
  </li>
  <li>
    <p>The record <code class="language-plaintext highlighter-rouge">BooleanAlgebra</code> now exports <code class="language-plaintext highlighter-rouge">∨-isSemigroup</code>, <code class="language-plaintext highlighter-rouge">∧-isSemigroup</code>
directly so <code class="language-plaintext highlighter-rouge">Algebra.Properties.BooleanAlgebra</code> no longer does so.</p>
  </li>
  <li>
    <p>The proof that every algebraic lattice induces a partial order has been
moved from <code class="language-plaintext highlighter-rouge">Algebra.Properties.Lattice</code> to
<code class="language-plaintext highlighter-rouge">Algebra.Properties.Semilattice</code>.  The corresponding <code class="language-plaintext highlighter-rouge">poset</code> instance is
re-exported in <code class="language-plaintext highlighter-rouge">Algebra.Properties.Lattice</code>.</p>
  </li>
  <li>
    <p>All algebraic structures now export left and right congruence properties.
For example this means <code class="language-plaintext highlighter-rouge">∙-cong refl x≈y</code> can be replaced with <code class="language-plaintext highlighter-rouge">∙-congˡ y≈z</code></p>
  </li>
</ul>

<h4 id="upgrade-of-equational-and-inequality-reasoning">Upgrade of equational and inequality reasoning</h4>

<ul>
  <li>The core Reasoning modules have been renamed as follows:
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Relation.Binary.EqReasoning                 ↦ Relation.Binary.Reasoning.Setoid
Relation.Binary.SetoidReasoning             ↦ Relation.Binary.Reasoning.MultiSetoid
Relation.Binary.PreorderReasoning           ↦ Relation.Binary.Reasoning.Preorder
Relation.Binary.PartialOrderReasoning       ↦ Relation.Binary.Reasoning.PartialOrder
Relation.Binary.StrictPartialOrderReasoning ↦ Relation.Binary.Reasoning.StrictPartialOrder
</code></pre></div>    </div>
    <p>The old modules have been deprecated but still exist for backwards compatibility reasons.</p>
  </li>
  <li>
    <p>The way reasoning is implemented has been changed. In particular all of the above
modules are specialised instances of the three modules
<code class="language-plaintext highlighter-rouge">Relation.Binary.Reasoning.Base.(Single/Double/Triple)</code>. This means that if you have
extended the reasoning modules yourself you may need to update the extensions.
However all <em>uses</em> of the reasoning modules are fully backwards compatible.</p>
  </li>
  <li>The new implementation allows the interleaving of both strict and non-strict links
in proofs. For example where as before the following:
    <pre><code class="language-agda">begin
  a  ≤⟨ x≤y ⟩
  b  &lt;⟨ y&lt;z ⟩
  c  ≤⟨ x≤y ⟩
  d  ∎
</code></pre>
    <p>was not a valid proof that <code class="language-plaintext highlighter-rouge">a ≤ d</code> due to the <code class="language-plaintext highlighter-rouge">&lt;</code> link in the middle, it is now accepted.</p>
  </li>
  <li>The new implementation can now be used to prove both equalities and strict inequalities as
well as basic inequalities. To do so use the new <code class="language-plaintext highlighter-rouge">begin-equality</code> and <code class="language-plaintext highlighter-rouge">begin-strict</code> combinators.
For instance replacing <code class="language-plaintext highlighter-rouge">begin</code> with <code class="language-plaintext highlighter-rouge">begin-strict</code> in the example above:
    <pre><code class="language-agda">begin-strict
  a  ≤⟨ x≤y ⟩
  b  &lt;⟨ y&lt;z ⟩
  c  ≤⟨ x≤y ⟩
  d  ∎
</code></pre>
    <p>proves that <code class="language-plaintext highlighter-rouge">a &lt; d</code> rather than <code class="language-plaintext highlighter-rouge">a ≤ d</code>.</p>
  </li>
  <li>New symmetric equality combinators  <code class="language-plaintext highlighter-rouge">_≈˘⟨_⟩_</code> and <code class="language-plaintext highlighter-rouge">_≡˘⟨_⟩_</code> have been added. Consequently
expressions of the form <code class="language-plaintext highlighter-rouge">x ≈⟨ sym y≈x ⟩ y</code> can be replaced with <code class="language-plaintext highlighter-rouge">x ≈˘⟨ y≈x ⟩ y</code>.</li>
</ul>

<h4 id="new-axiom-modules">New <code class="language-plaintext highlighter-rouge">Axiom</code> modules</h4>

<ul>
  <li>
    <p>A new top level <code class="language-plaintext highlighter-rouge">Axiom</code> directory has been created that contains modules
for various additional axioms that users may want to postulate.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Excluded-Middle</code> and associated proofs have been moved out of <code class="language-plaintext highlighter-rouge">Relation.Nullary.Negation</code>
and into <code class="language-plaintext highlighter-rouge">Axiom.ExcludedMiddle</code>.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Extensionality</code> and associated proofs have been moved out of
<code class="language-plaintext highlighter-rouge">Relation.Binary.PropositionalEquality</code> and into <code class="language-plaintext highlighter-rouge">Axiom.Extensionality.Propositional</code>.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Extensionality</code> and associated proofs have been moved out of
<code class="language-plaintext highlighter-rouge">Relation.Binary.HeterogeneousEquality</code> and into <code class="language-plaintext highlighter-rouge">Axiom.Extensionality.Heterogeneous</code>.</p>
  </li>
  <li>
    <p>The old names still exist for backwards compatability but have been deprecated.</p>
  </li>
  <li>
    <p>Changed the type of <code class="language-plaintext highlighter-rouge">≡-≟-identity</code> in <code class="language-plaintext highlighter-rouge">Relation.Binary.PropositionalEquality</code>
to make use of the fact that equality being decidable implies uniqueness of identity proofs.</p>
  </li>
</ul>

<h4 id="relaxation-of-ring-solvers-requirements">Relaxation of ring solvers requirements</h4>

<ul>
  <li>In the ring solvers the assumption that equality is <code class="language-plaintext highlighter-rouge">Decidable</code>
has been replaced by a strictly weaker assumption that it is <code class="language-plaintext highlighter-rouge">WeaklyDecidable</code>.
This allows the solvers to be used when equality is not fully decidable.
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Algebra.Solver.Ring
Algebra.Solver.Ring.NaturalCoefficients
</code></pre></div>    </div>
  </li>
  <li>Created a module <code class="language-plaintext highlighter-rouge">Algebra.Solver.Ring.NaturalCoefficients.Default</code> that
instantiates the solver for any <code class="language-plaintext highlighter-rouge">CommutativeSemiring</code>.</li>
</ul>

<h4 id="new-datasumproductfunction-directories">New <code class="language-plaintext highlighter-rouge">Data.Sum/Product.Function</code> directories</h4>

<ul>
  <li>
    <p>Various combinators for types of functions (injections, surjections, inverses etc.)
over <code class="language-plaintext highlighter-rouge">Sum</code> and <code class="language-plaintext highlighter-rouge">Product</code> currently live in the <code class="language-plaintext highlighter-rouge">Data.(Product/Sum).Relation.Binary.Pointwise</code>
modules. These are poorly placed as the properties a) do not directly reference <code class="language-plaintext highlighter-rouge">Pointwise</code>
and b) are very hard to locate.</p>
  </li>
  <li>
    <p>They have therefore been moved into the new <code class="language-plaintext highlighter-rouge">Data.(Product/Sum).Function</code> directory
as follows:</p>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Data.Product.Relation.Binary.Pointwise.Dependent    ↦ Data.Product.Function.Dependent.Setoid
                                                    ↘ Data.Product.Function.Dependent.Propositional
Data.Product.Relation.Binary.Pointwise.NonDependent ↦ Data.Product.Function.NonDependent.Setoid
                                                    ↘ Data.Product.Function.NonDependent.Propositional
Data.Sum.Relation.Binary.Pointwise.Dependent        ↦ Data.Sum.Function.Setoid
                                                    ↘ Data.Sum.Function.Propositional
</code></pre></div>    </div>
    <p>All the proofs about <code class="language-plaintext highlighter-rouge">Pointwise</code> remain untouched.</p>
  </li>
</ul>

<h4 id="overhaul-of-dataavl">Overhaul of <code class="language-plaintext highlighter-rouge">Data.AVL</code></h4>

<ul>
  <li>
    <p>AVL trees now work over arbitrary equalities, rather than just
propositional equality.</p>
  </li>
  <li>
    <p>Consequently the family of <code class="language-plaintext highlighter-rouge">Value</code>s stored in the tree now need
to respect the <code class="language-plaintext highlighter-rouge">Key</code> equivalence</p>
  </li>
  <li>
    <p>The module parameter for <code class="language-plaintext highlighter-rouge">Data.AVL</code>, <code class="language-plaintext highlighter-rouge">Data.AVL.Indexed</code>, <code class="language-plaintext highlighter-rouge">Data.AVL.Key</code>,
<code class="language-plaintext highlighter-rouge">Data.AVL.Sets</code> is now a <code class="language-plaintext highlighter-rouge">StrictTotalOrder</code> rather than a
<code class="language-plaintext highlighter-rouge">IsStrictTotalOrder</code>, and the module parameter for <code class="language-plaintext highlighter-rouge">Data.AVL.Value</code> is
now takes a <code class="language-plaintext highlighter-rouge">Setoid</code> rather than an <code class="language-plaintext highlighter-rouge">IsEquivalence</code>.</p>
  </li>
  <li>
    <p>It was noticed that <code class="language-plaintext highlighter-rouge">Data.AVL.Indexed</code>’s lookup &amp; delete didn’t use
a range to guarantee that the recursive calls were performed in the
right subtree. The types have been made more precise.</p>
  </li>
  <li>
    <p>The functions <code class="language-plaintext highlighter-rouge">(insert/union)With</code> now take a function of type
<code class="language-plaintext highlighter-rouge">Maybe Val -&gt; Val</code> rather than a value together with a merging function
<code class="language-plaintext highlighter-rouge">Val -&gt; Val -&gt; Val</code> to handle the case where a value is already present
at that key.</p>
  </li>
  <li>
    <p>Various functions have been made polymorphic which makes their biases
&amp; limitations clearer. e.g. we have:
<code class="language-plaintext highlighter-rouge">unionWith : (V -&gt; Maybe W -&gt; W) -&gt; Tree V -&gt; Tree W -&gt; Tree W</code>
but ideally we would like to have:
<code class="language-plaintext highlighter-rouge">unionWith : (These V W -&gt; X) -&gt; Tree V -&gt; Tree W -&gt; Tree X</code></p>
  </li>
  <li>
    <p>Keys are now implemented via the new <code class="language-plaintext highlighter-rouge">Relation.(Binary/Nullary).Construct.AddExtrema</code>
modules.</p>
  </li>
</ul>

<h4 id="overhaul-of-datacontainer">Overhaul of <code class="language-plaintext highlighter-rouge">Data.Container</code></h4>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Data.Container</code> has been split up into the standard hierarchy.</p>
  </li>
  <li>
    <p>Moved <code class="language-plaintext highlighter-rouge">Data.Container</code>’s <code class="language-plaintext highlighter-rouge">All</code> and <code class="language-plaintext highlighter-rouge">Any</code> into their own
<code class="language-plaintext highlighter-rouge">Data.Container.Relation.Unary.X</code> module. Made them record types
to improve type inference.</p>
  </li>
  <li>
    <p>Moved morphisms to <code class="language-plaintext highlighter-rouge">Data.Container.Morphism</code> and their properties
to <code class="language-plaintext highlighter-rouge">Data.Container.Morphism.Properties</code>.</p>
  </li>
  <li>
    <p>Made the index set explicit in <code class="language-plaintext highlighter-rouge">Data.Container.Combinator</code>’s <code class="language-plaintext highlighter-rouge">Π</code> and <code class="language-plaintext highlighter-rouge">Σ</code>.</p>
  </li>
  <li>
    <p>Moved <code class="language-plaintext highlighter-rouge">Eq</code> to <code class="language-plaintext highlighter-rouge">Data.Container.Relation.Binary.Pointwise</code>
(and renamed it to <code class="language-plaintext highlighter-rouge">Pointwise</code>) and its properties to
<code class="language-plaintext highlighter-rouge">Data.Container.Relation.Binary.Pointwise.Properties</code>.</p>
  </li>
  <li>
    <p>The type family <code class="language-plaintext highlighter-rouge">Data.Container.ν</code> is now defined using <code class="language-plaintext highlighter-rouge">Codata.M.M</code>
rather than Codata.Musical.M.M`.</p>
  </li>
</ul>

<h4 id="overhaul-of-datamaybe">Overhaul of <code class="language-plaintext highlighter-rouge">Data.Maybe</code></h4>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Data.Maybe</code> has been split up into the standard hierarchy for
container datatypes.</p>
  </li>
  <li>
    <p>Moved <code class="language-plaintext highlighter-rouge">Data.Maybe.Base</code>’s <code class="language-plaintext highlighter-rouge">Is-just</code>, <code class="language-plaintext highlighter-rouge">Is-nothing</code>, <code class="language-plaintext highlighter-rouge">to-witness</code>,
and <code class="language-plaintext highlighter-rouge">to-witness-T</code> to <code class="language-plaintext highlighter-rouge">Data.Maybe</code> (they rely on <code class="language-plaintext highlighter-rouge">All</code> and <code class="language-plaintext highlighter-rouge">Any</code>
which are now outside of <code class="language-plaintext highlighter-rouge">Data.Maybe.Base</code>).</p>
  </li>
  <li>
    <p>Moved <code class="language-plaintext highlighter-rouge">Data.Maybe.Base</code>’s <code class="language-plaintext highlighter-rouge">All</code> and <code class="language-plaintext highlighter-rouge">Data.Maybe</code>’s <code class="language-plaintext highlighter-rouge">allDec</code> to
<code class="language-plaintext highlighter-rouge">Data.Maybe.Relation.Unary.All</code> and renamed the proof <code class="language-plaintext highlighter-rouge">allDec</code> to <code class="language-plaintext highlighter-rouge">dec</code>.</p>
  </li>
  <li>
    <p>Moved <code class="language-plaintext highlighter-rouge">Data.Maybe.Base</code>’s <code class="language-plaintext highlighter-rouge">Any</code> and <code class="language-plaintext highlighter-rouge">Data.Maybe</code>’s <code class="language-plaintext highlighter-rouge">anyDec</code> to
<code class="language-plaintext highlighter-rouge">Data.Maybe.Relation.Unary.Any</code> and renamed the proof <code class="language-plaintext highlighter-rouge">anyDec</code> to <code class="language-plaintext highlighter-rouge">dec</code>.</p>
  </li>
  <li>
    <p>Created <code class="language-plaintext highlighter-rouge">Data.Maybe.Properties</code> and moved <code class="language-plaintext highlighter-rouge">Data.Maybe.Base</code>’s <code class="language-plaintext highlighter-rouge">just-injective</code>
into it and added new results.</p>
  </li>
  <li>
    <p>Moved <code class="language-plaintext highlighter-rouge">Data.Maybe</code>’s <code class="language-plaintext highlighter-rouge">Eq</code> to <code class="language-plaintext highlighter-rouge">Data.Maybe.Relation.Binary.Pointwise</code>, made the
relation heterogeneously typed and renamed the following proofs:</p>
    <pre><code class="language-agda">Eq                  ↦ Pointwise
Eq-refl             ↦ refl
Eq-sym              ↦ sym
Eq-trans            ↦ trans
Eq-dec              ↦ dec
Eq-isEquivalence    ↦ isEquivalence
Eq-isDecEquivalence ↦ isDecEquivalence
</code></pre>
  </li>
</ul>

<h4 id="overhaul-of-datasumrelationbinary">Overhaul of <code class="language-plaintext highlighter-rouge">Data.Sum.Relation.Binary</code></h4>

<ul>
  <li>
    <p>The implementations of <code class="language-plaintext highlighter-rouge">Data.Sum.Relation.Binary.(Pointwise/LeftOrder)</code> have been altered
to bring them in line with implementations of similar orders for other datatypes.
Namely they are no longer specialised instances of some <code class="language-plaintext highlighter-rouge">Core</code> module.</p>
  </li>
  <li>
    <p>The constructor <code class="language-plaintext highlighter-rouge">₁∼₂</code> for <code class="language-plaintext highlighter-rouge">LeftOrder</code> no longer takes an argument of type <code class="language-plaintext highlighter-rouge">⊤</code>.</p>
  </li>
  <li>
    <p>The constructor <code class="language-plaintext highlighter-rouge">₁∼₁</code> and <code class="language-plaintext highlighter-rouge">₂∼₂</code> in <code class="language-plaintext highlighter-rouge">Pointwise</code> have been renamed <code class="language-plaintext highlighter-rouge">inj₁</code> and <code class="language-plaintext highlighter-rouge">inj₂</code>
respectively. The old names still exist but have been deprecated.</p>
  </li>
</ul>

<h4 id="overhaul-of-monadzero-and-monadplus">Overhaul of <code class="language-plaintext highlighter-rouge">MonadZero</code> and <code class="language-plaintext highlighter-rouge">MonadPlus</code></h4>

<ul>
  <li>
    <p>Introduce <code class="language-plaintext highlighter-rouge">RawIApplicativeZero</code> for an indexed applicative with a zero
and <code class="language-plaintext highlighter-rouge">RawAlternative</code> for an indexed applicative with a zero and a sum.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">RawIMonadZero</code> is now packing a <code class="language-plaintext highlighter-rouge">RawIApplicativeZero</code> rather than a <code class="language-plaintext highlighter-rouge">∅</code> directly</p>
  </li>
  <li>
    <p>Similarly <code class="language-plaintext highlighter-rouge">RawIMonadPlus</code> is defined in terms of <code class="language-plaintext highlighter-rouge">RawIAlternative</code> rather than
directly packing a <em>∣</em>.</p>
  </li>
  <li>
    <p>Instances will be broken but usages should still work thanks to re-exports striving
to maintain backwards compatibility.</p>
  </li>
</ul>

<h4 id="overhaul-of-datachar-and-datastring">Overhaul of <code class="language-plaintext highlighter-rouge">Data.Char</code> and <code class="language-plaintext highlighter-rouge">Data.String</code></h4>

<ul>
  <li>
    <p>Moved <code class="language-plaintext highlighter-rouge">setoid</code> and <code class="language-plaintext highlighter-rouge">strictTotalOrder</code> from <code class="language-plaintext highlighter-rouge">Data.(Char/String)</code> into the new
module <code class="language-plaintext highlighter-rouge">Data.(Char/String).Properties</code>.</p>
  </li>
  <li>
    <p>Used the new builtins from <code class="language-plaintext highlighter-rouge">Agda.Builtin.(Char/String).Properties</code> to implement
decidable equality (<code class="language-plaintext highlighter-rouge">_≟_</code>) in a safe manner. This has allowed <code class="language-plaintext highlighter-rouge">_≟_</code>,
<code class="language-plaintext highlighter-rouge">decSetoid</code> and <code class="language-plaintext highlighter-rouge">_==_</code> to be moved from <code class="language-plaintext highlighter-rouge">Data.(Char/String).Unsafe</code> to
<code class="language-plaintext highlighter-rouge">Data.(Char/String).Properties</code>.</p>
  </li>
</ul>

<h4 id="overhaul-of-datarational">Overhaul of <code class="language-plaintext highlighter-rouge">Data.Rational</code></h4>

<ul>
  <li>
    <p>Many new operators have been added to <code class="language-plaintext highlighter-rouge">Data.Rational</code> including
addition, substraction, multiplication, inverse etc.</p>
  </li>
  <li>
    <p>The existing operator <code class="language-plaintext highlighter-rouge">_÷_</code> has been renamed <code class="language-plaintext highlighter-rouge">_/_</code> and is now more liberal
as it now accepts non-coprime arguments (e.g. <code class="language-plaintext highlighter-rouge">+ 2 / 4</code>) which are then
normalised.</p>
  </li>
  <li>
    <p>The old name <code class="language-plaintext highlighter-rouge">_÷_</code> has been repurposed to represent division between two
rationals.</p>
  </li>
  <li>
    <p>The proofs <code class="language-plaintext highlighter-rouge">drop-*≤*</code>, <code class="language-plaintext highlighter-rouge">≃⇒≡</code> and <code class="language-plaintext highlighter-rouge">≡⇒≃</code> have been moved from <code class="language-plaintext highlighter-rouge">Data.Rational</code>
to <code class="language-plaintext highlighter-rouge">Data.Rational.Properties</code>.</p>
  </li>
</ul>

<h4 id="changes-in-datalist">Changes in <code class="language-plaintext highlighter-rouge">Data.List</code></h4>

<ul>
  <li>In <code class="language-plaintext highlighter-rouge">Data.List.Membership.Propositional.Properties</code>:
    <ul>
      <li>the <code class="language-plaintext highlighter-rouge">Set</code> argument has been made implicit in <code class="language-plaintext highlighter-rouge">∈-++⁺ˡ</code>, <code class="language-plaintext highlighter-rouge">∈-++⁺ʳ</code>, <code class="language-plaintext highlighter-rouge">∈-++⁻</code>, <code class="language-plaintext highlighter-rouge">∈-insert</code>, <code class="language-plaintext highlighter-rouge">∈-∃++</code>.</li>
      <li>the <code class="language-plaintext highlighter-rouge">A → B</code> argument has been made explicit in <code class="language-plaintext highlighter-rouge">∈-map⁺</code>, <code class="language-plaintext highlighter-rouge">∈-map⁻</code>, <code class="language-plaintext highlighter-rouge">map-∈↔</code>.</li>
    </ul>
  </li>
  <li>
    <p>The module <code class="language-plaintext highlighter-rouge">Data.List.Relation.Binary.Sublist.Propositional.Solver</code> has been removed
and replaced by <code class="language-plaintext highlighter-rouge">Data.List.Relation.Binary.Sublist.DecPropositional.Solver</code>.</p>
  </li>
  <li>The functions <code class="language-plaintext highlighter-rouge">_∷=_</code> and <code class="language-plaintext highlighter-rouge">_─_</code> have been removed from <code class="language-plaintext highlighter-rouge">Data.List.Membership.Setoid</code>
as they are subsumed by the more general versions now part of <code class="language-plaintext highlighter-rouge">Data.List.Any</code>.</li>
</ul>

<h4 id="changes-in-datanat">Changes in <code class="language-plaintext highlighter-rouge">Data.Nat</code></h4>

<ul>
  <li>
    <p>Changed the implementation of <code class="language-plaintext highlighter-rouge">_≟_</code> and <code class="language-plaintext highlighter-rouge">_≤″?_</code> for natural numbers
to use a (fast) boolean test. Compiled code that uses these should
now run faster.</p>
  </li>
  <li>
    <p>Made the contents of the modules <code class="language-plaintext highlighter-rouge">Data.Nat.Unsafe</code> and <code class="language-plaintext highlighter-rouge">Data.Nat.DivMod.Unsafe</code>
safe by using the new safe equality erasure primitive instead of the
unsafe one defined in <code class="language-plaintext highlighter-rouge">Relation.Binary.PropositionalEquality.TrustMe</code>. As the
safe erasure primitive requires the K axiom the two files are now named
<code class="language-plaintext highlighter-rouge">Data.Nat.WithK</code> and <code class="language-plaintext highlighter-rouge">Data.Nat.DivMod.WithK</code>.</p>
  </li>
  <li>
    <p>Fixed a bug in <code class="language-plaintext highlighter-rouge">Data.Nat.Properties</code> where the type of <code class="language-plaintext highlighter-rouge">m⊓n≤m⊔n</code> was
<code class="language-plaintext highlighter-rouge">∀ m n → m ⊔ n ≤ m ⊔ n</code>. The type has been corrected to <code class="language-plaintext highlighter-rouge">∀ m n → m ⊓ n ≤ m ⊔ n</code>.</p>
  </li>
</ul>

<h4 id="changes-in-datavec">Changes in <code class="language-plaintext highlighter-rouge">Data.Vec</code></h4>

<ul>
  <li>
    <p>The argument order for <code class="language-plaintext highlighter-rouge">lookup</code>, <code class="language-plaintext highlighter-rouge">insert</code> and <code class="language-plaintext highlighter-rouge">remove</code> in <code class="language-plaintext highlighter-rouge">Data.Vec</code> has been altered
so that the <code class="language-plaintext highlighter-rouge">Vec</code> argument always come first, e.g. what was written as <code class="language-plaintext highlighter-rouge">lookup i v xs</code> is
now <code class="language-plaintext highlighter-rouge">lookup xs i v</code>. The argument order for the corresponding proofs has also changed.
This makes the operations more consistent with those in <code class="language-plaintext highlighter-rouge">Data.List</code>.</p>
  </li>
  <li>
    <p>The proofs <code class="language-plaintext highlighter-rouge">toList⁺</code> and <code class="language-plaintext highlighter-rouge">toList⁻</code> in <code class="language-plaintext highlighter-rouge">Data.Vec.Relation.Unary.All.Properties</code> have been swapped
as they were the opposite way round to similar properties in the rest of the library.</p>
  </li>
</ul>

<h4 id="other-changes">Other changes</h4>

<ul>
  <li>
    <p>The proof <code class="language-plaintext highlighter-rouge">sel⇒idem</code> in <code class="language-plaintext highlighter-rouge">Algebra.FunctionProperties.Consequences</code> now
only takes the equality relation as an argument instead of a full <code class="language-plaintext highlighter-rouge">Setoid</code>.</p>
  </li>
  <li>
    <p>The proof <code class="language-plaintext highlighter-rouge">_≟_</code> that equality is decidable for <code class="language-plaintext highlighter-rouge">Bool</code> has been moved
from <code class="language-plaintext highlighter-rouge">Data.Bool.Base</code> to <code class="language-plaintext highlighter-rouge">Data.Bool.Properties</code>. Backwards compatibility
has been (nearly completely) preserved by having <code class="language-plaintext highlighter-rouge">Data.Bool</code> publicly re-export <code class="language-plaintext highlighter-rouge">_≟_</code>.</p>
  </li>
  <li>
    <p>The type <code class="language-plaintext highlighter-rouge">Coprime</code> and proof <code class="language-plaintext highlighter-rouge">coprime-divisor</code> have been moved from
<code class="language-plaintext highlighter-rouge">Data.Integer.Divisibility</code> to <code class="language-plaintext highlighter-rouge">Data.Integer.Coprimality</code>.</p>
  </li>
  <li>
    <p>The functions <code class="language-plaintext highlighter-rouge">fromMusical</code> and <code class="language-plaintext highlighter-rouge">toMusical</code> were moved from the <code class="language-plaintext highlighter-rouge">Codata</code> modules
to the corresponding <code class="language-plaintext highlighter-rouge">Codata.Musical</code> modules.</p>
  </li>
</ul>

<h2 id="removed-features">Removed features</h2>

<ul>
  <li>The following modules that were deprecated in v0.14 and v0.15 have been removed.
    <pre><code class="language-agda">Data.Nat.Properties.Simple
Data.Integer.Multiplication.Properties
Data.Integer.Addition.Properties

Relation.Binary.Sigma.Pointwise
Relation.Binary.Sum
Relation.Binary.List.NonStrictLex
Relation.Binary.List.Pointwise
Relation.Binary.List.StrictLex
Relation.Binary.Product.NonStrictLex
Relation.Binary.Product.Pointwise
Relation.Binary.Product.StrictLex
Relation.Binary.Vec.Pointwise
</code></pre>
  </li>
</ul>

<h2 id="deprecated-features">Deprecated features</h2>

<p>The following renaming has occurred as part of a drive to improve
consistency across the library. The old names still exist and therefore
all existing code should still work, however they have been deprecated
and use of the new names is encouraged. Although not anticipated any
time soon, they may eventually be removed in some future release of the library.</p>

<ul>
  <li>In <code class="language-plaintext highlighter-rouge">Data.Bool.Properties</code>:
    <pre><code class="language-agda">T-irrelevance ↦ T-irrelevant
</code></pre>
  </li>
  <li>In <code class="language-plaintext highlighter-rouge">Data.Fin.Properties</code>:
    <pre><code class="language-agda">≤-irrelevance ↦ ≤-irrelevant
&lt;-irrelevance ↦ &lt;-irrelevant
</code></pre>
  </li>
  <li>In <code class="language-plaintext highlighter-rouge">Data.Integer.Properties</code>:
    <pre><code class="language-agda">≰→&gt;           ↦ ≰⇒&gt;
≤-irrelevance ↦ ≤-irrelevant
&lt;-irrelevance ↦ &lt;-irrelevant
</code></pre>
  </li>
  <li>In <code class="language-plaintext highlighter-rouge">Data.List.Relation.Binary.Permutation.Inductive.Properties</code>:
    <pre><code class="language-agda">↭⇒~bag ↦ ↭⇒∼bag
~bag⇒↭ ↦ ∼bag⇒↭
</code></pre>
    <p>(now typed with “\sim” rather than “~”)</p>
  </li>
  <li>In <code class="language-plaintext highlighter-rouge">Data.List.Relation.Binary.Pointwise</code>:
    <pre><code class="language-agda">decidable-≡   ↦ Data.List.Properties.≡-dec
</code></pre>
  </li>
  <li>In <code class="language-plaintext highlighter-rouge">Data.List.Relation.Unary.All.Properties</code>:
    <pre><code class="language-agda">filter⁺₁ ↦ all-filter
filter⁺₂ ↦ filter⁺
</code></pre>
  </li>
  <li>In <code class="language-plaintext highlighter-rouge">Data.Nat.Properties</code>:
    <pre><code class="language-agda">≤-irrelevance ↦ ≤-irrelevant
&lt;-irrelevance ↦ &lt;-irrelevant
</code></pre>
  </li>
  <li>In <code class="language-plaintext highlighter-rouge">Data.Rational</code>:
    <pre><code class="language-agda">drop-*≤*
≃⇒≡
≡⇒≃
</code></pre>
    <p>(moved to <code class="language-plaintext highlighter-rouge">Data.Rational.Properties</code>)</p>
  </li>
  <li>In <code class="language-plaintext highlighter-rouge">Data.Rational.Properties</code>:
    <pre><code class="language-agda">≤-irrelevance ↦ ≤-irrelevant
</code></pre>
  </li>
  <li>In <code class="language-plaintext highlighter-rouge">Data.Vec.Properties.WithK</code>:
    <pre><code class="language-agda">[]=-irrelevance ↦ []=-irrelevant
</code></pre>
  </li>
  <li>In <code class="language-plaintext highlighter-rouge">Relation.Binary.HeterogeneousEquality</code>:
    <pre><code class="language-agda">≅-irrelevance                ↦ ≅-irrelevant
≅-heterogeneous-irrelevance  ↦ ≅-heterogeneous-irrelevant
≅-heterogeneous-irrelevanceˡ ↦ ≅-heterogeneous-irrelevantˡ
≅-heterogeneous-irrelevanceʳ ↦ ≅-heterogeneous-irrelevantʳ
</code></pre>
  </li>
  <li>In <code class="language-plaintext highlighter-rouge">Induction.WellFounded</code>:
    <pre><code class="language-agda">module Inverse-image      ↦ InverseImage
module Transitive-closure ↦ TransitiveClosure
</code></pre>
  </li>
  <li>In <code class="language-plaintext highlighter-rouge">Relation.Binary.PropositionalEquality.WithK</code>:
    <pre><code class="language-agda">≡-irrelevance ↦ ≡-irrelevant
</code></pre>
  </li>
</ul>

<h2 id="other-minor-additions">Other minor additions</h2>

<ul>
  <li>Added new records to <code class="language-plaintext highlighter-rouge">Algebra</code>:
    <pre><code class="language-agda">record RawMagma c ℓ : Set (suc (c ⊔ ℓ))
record Magma    c ℓ : Set (suc (c ⊔ ℓ))
</code></pre>
  </li>
  <li>Added new types to <code class="language-plaintext highlighter-rouge">Algebra.FunctionProperties</code>:
    <pre><code class="language-agda">LeftConical  e _∙_ = ∀ x y → (x ∙ y) ≈ e → x ≈ e
RightConical e _∙_ = ∀ x y → (x ∙ y) ≈ e → y ≈ e
Conical e ∙        = LeftConical e ∙ × RightConical e ∙

LeftCongruent  _∙_ = ∀ {x} → (x ∙_) Preserves _≈_ ⟶ _≈_
RightCongruent _∙_ = ∀ {x} → (_∙ x) Preserves _≈_ ⟶ _≈_
</code></pre>
  </li>
  <li>Added new proof to <code class="language-plaintext highlighter-rouge">Algebra.FunctionProperties.Consequences</code>:
    <pre><code class="language-agda">wlog : Commutative f → Total _R_ → (∀ a b → a R b → P (f a b)) → ∀ a b → P (f a b)
</code></pre>
  </li>
  <li>Added new proofs to <code class="language-plaintext highlighter-rouge">Algebra.Properties.Lattice</code>:
    <pre><code class="language-agda">∧-isSemilattice : IsSemilattice _≈_ _∧_
∧-semilattice   : Semilattice l₁ l₂
∨-isSemilattice : IsSemilattice _≈_ _∨_
∨-semilattice   : Semilattice l₁ l₂
</code></pre>
  </li>
  <li>Added new operator to <code class="language-plaintext highlighter-rouge">Algebra.Solver.Ring</code>.
    <pre><code class="language-agda">_:×_
</code></pre>
  </li>
  <li>Added new records to <code class="language-plaintext highlighter-rouge">Algebra.Structures</code>:
    <pre><code class="language-agda">record IsMagma (∙ : Op₂ A) : Set (a ⊔ ℓ)
</code></pre>
  </li>
  <li>Added new proofs to <code class="language-plaintext highlighter-rouge">Category.Monad.State</code>:
    <pre><code class="language-agda">StateTIApplicative     : RawMonad     M → RawIApplicative     (IStateT S M)
StateTIApplicativeZero : RawMonadZero M → RawIApplicativeZero (IStateT S M)
StateTIAlternative     : RawMonadPlus M → RawIAlternative     (IStateT S M)
</code></pre>
  </li>
  <li>Added new functions to <code class="language-plaintext highlighter-rouge">Codata.Colist</code>:
    <pre><code class="language-agda">fromCowriter : Cowriter W A i → Colist W i
toCowriter   : Colist A i → Cowriter A ⊤ i
[_]          : A → Colist A ∞
chunksOf     : (n : ℕ) → Colist A ∞ → Cowriter (Vec A n) (BoundedVec A n) ∞
</code></pre>
  </li>
  <li>Added new proofs to <code class="language-plaintext highlighter-rouge">Codata.Delay.Categorical</code>:
    <pre><code class="language-agda">Sequential.applicativeZero : RawApplicativeZero (λ A → Delay A i)
Zippy.applicativeZero      : RawApplicativeZero (λ A → Delay A i)
Zippy.alternative          : RawAlternative     (λ A → Delay A i)
</code></pre>
  </li>
  <li>Added new functions to <code class="language-plaintext highlighter-rouge">Codata.Stream</code>:
    <pre><code class="language-agda">splitAt    : (n : ℕ) → Stream A ∞ → Vec A n × Stream A ∞
drop       : ℕ → Stream A ∞ → Stream A ∞
interleave : Stream A i → Thunk (Stream A) i → Stream A i
chunksOf   : (n : ℕ) → Stream A ∞ → Stream (Vec A n) ∞
</code></pre>
  </li>
  <li>Added new proofs to <code class="language-plaintext highlighter-rouge">Codata.Stream.Properties</code>:
    <pre><code class="language-agda">splitAt-map             : splitAt n (map f xs) ≡ map (map f) (map f) (splitAt n xs)
lookup-iterate-identity : lookup n (iterate f a) ≡ fold a f n
</code></pre>
  </li>
  <li>Added new proofs to <code class="language-plaintext highlighter-rouge">Data.Bool.Properties</code>:
    <pre><code class="language-agda">∧-isMagma       : IsMagma _∧_
∨-isMagma       : IsMagma _∨_
∨-isBand        : IsBand _∨_
∨-isSemilattice : IsSemilattice _∨_
∧-isBand        : IsBand _∧_
∧-isSemilattice : IsSemilattice _∧_

∧-magma         : Magma 0ℓ 0ℓ
∨-magma         : Magma 0ℓ 0ℓ
∨-band          : Band 0ℓ 0ℓ
∧-band          : Band 0ℓ 0ℓ
∨-semilattice   : Semilattice 0ℓ 0ℓ
∧-semilattice   : Semilattice 0ℓ 0ℓ

T?              : Decidable T
T?-diag         : T b → True (T? b)
</code></pre>
  </li>
  <li>Added new functions to <code class="language-plaintext highlighter-rouge">Data.Char</code>:
    <pre><code class="language-agda">toUpper : Char → Char
toLower : Char → Char
</code></pre>
  </li>
  <li>Added new functions to <code class="language-plaintext highlighter-rouge">Data.Fin.Base</code>:
    <pre><code class="language-agda">cast   : m ≡ n → Fin m → Fin n
lower₁ : (i : Fin (suc n)) → (n ≢ toℕ i) → Fin n
</code></pre>
  </li>
  <li>Added new proof to <code class="language-plaintext highlighter-rouge">Data.Fin.Properties</code>:
    <pre><code class="language-agda">toℕ-cast          : toℕ (cast eq k) ≡ toℕ k
toℕ-inject₁-≢     : n ≢ toℕ (inject₁ i)

inject₁-lower₁    : inject₁ (lower₁ i n≢i) ≡ i
lower₁-inject₁′   : lower₁ (inject₁ i) n≢i ≡ i
lower₁-inject₁    : lower₁ (inject₁ i) (toℕ-inject₁-≢ i) ≡ i
lower₁-irrelevant : lower₁ i n≢i₁ ≡ lower₁ i n≢i₂
</code></pre>
  </li>
  <li>Added new proofs to <code class="language-plaintext highlighter-rouge">Data.Fin.Subset.Properties</code>:
    <pre><code class="language-agda">∩-isMagma       : IsMagma _∩_
∪-isMagma       : IsMagma _∪_
∩-isBand        : IsBand _∩_
∪-isBand        : IsBand _∪_
∩-isSemilattice : IsSemilattice _∩_
∪-isSemilattice : IsSemilattice _∪_

∩-magma         : Magma _ _
∪-magma         : Magma _ _
∩-band          : Band _ _
∪-band          : Band _ _
∩-semilattice   : Semilattice _ _
∪-semilattice   : Semilattice _ _
</code></pre>
  </li>
  <li>Added new proofs to <code class="language-plaintext highlighter-rouge">Data.Integer.Properties</code>:
    <pre><code class="language-agda">suc-pred          : sucℤ (pred m) ≡ m
pred-suc          : pred (sucℤ m) ≡ m
neg-suc           : - + suc m ≡ pred (- + m)
suc-+             : + suc m + n ≡ sucℤ (+ m + n)
+-pred            : m + pred n ≡ pred (m + n)
pred-+            : pred m + n ≡ pred (m + n)
minus-suc         : m - + suc n ≡ pred (m - + n)
[1+m]*n≡n+m*n     : sucℤ m * n ≡ n + m * n

⊓-comm            : Commutative _⊓_
⊓-assoc           : Associative _⊓_
⊓-idem            : Idempotent _⊓_
⊓-sel             : Selective _⊓_
m≤n⇒m⊓n≡m         : m ≤ n → m ⊓ n ≡ m
m⊓n≡m⇒m≤n         : m ⊓ n ≡ m → m ≤ n
m≥n⇒m⊓n≡n         : m ≥ n → m ⊓ n ≡ n
m⊓n≡n⇒m≥n         : m ⊓ n ≡ n → m ≥ n
m⊓n≤n             : m ⊓ n ≤ n
m⊓n≤m             : m ⊓ n ≤ m

⊔-comm            : Commutative _⊔_
⊔-assoc           : Associative _⊔_
⊔-idem            : Idempotent _⊔_
⊔-sel             : Selective _⊔_
m≤n⇒m⊔n≡n         : m ≤ n → m ⊔ n ≡ n
m⊔n≡n⇒m≤n         : m ⊔ n ≡ n → m ≤ n
m≥n⇒m⊔n≡m         : m ≥ n → m ⊔ n ≡ m
m⊔n≡m⇒m≥n         : m ⊔ n ≡ m → m ≥ n
m≤m⊔n             : m ≤ m ⊔ n
n≤m⊔n             : n ≤ m ⊔ n

neg-distrib-⊔-⊓   : - (m ⊔ n) ≡ - m ⊓ - n
neg-distrib-⊓-⊔   : - (m ⊓ n) ≡ - m ⊔ - n

pred-mono         : pred Preserves _≤_ ⟶ _≤_
suc-mono          : sucℤ Preserves _≤_ ⟶ _≤_
⊖-monoʳ-≥-≤       : (p ⊖_) Preserves ℕ._≥_ ⟶ _≤_
⊖-monoˡ-≤         : (_⊖ p) Preserves ℕ._≤_ ⟶ _≤_
+-monoʳ-≤         : (_+_ n) Preserves _≤_ ⟶ _≤_
+-monoˡ-≤         : (_+ n) Preserves _≤_ ⟶ _≤_
+-monoˡ-&lt;         : (_+ n) Preserves _&lt;_ ⟶ _&lt;_
+-monoʳ-&lt;         : (_+_ n) Preserves _&lt;_ ⟶ _&lt;_
*-monoˡ-≤-pos     : (+ suc n *_) Preserves _≤_ ⟶ _≤_
*-monoʳ-≤-non-neg : (_* + n) Preserves _≤_ ⟶ _≤
*-monoˡ-≤-non-neg : (+ n *_) Preserves _≤_ ⟶ _≤_
+-mono-≤          : _+_ Preserves₂ _≤_ ⟶ _≤_ ⟶ _≤_
+-mono-&lt;          : _+_ Preserves₂ _&lt;_ ⟶ _&lt;_ ⟶ _&lt;_
+-mono-≤-&lt;        : _+_ Preserves₂ _≤_ ⟶ _&lt;_ ⟶ _&lt;_
+-mono-&lt;-≤        : _+_ Preserves₂ _&lt;_ ⟶ _≤_ ⟶ _&lt;_
neg-mono-≤-≥      : -_ Preserves _≤_ ⟶ _≥_
neg-mono-&lt;-&gt;      : -_ Preserves _&lt;_ ⟶ _&gt;_

*-cancelˡ-≡       : i ≢ + 0 → i * j ≡ i * k → j ≡ k
*-cancelˡ-≤-pos   : + suc m * n ≤ + suc m * o → n ≤ o

neg-≤-pos         : - (+ m) ≤ + n
0⊖m≤+             : 0 ⊖ m ≤ + n
m≤n⇒m-n≤0         : m ≤ n → m - n ≤ + 0
m-n≤0⇒m≤n         : m - n ≤ + 0 → m ≤ n
m≤n⇒0≤n-m         : m ≤ n → + 0 ≤ n - m
0≤n-m⇒m≤n         : + 0 ≤ n - m → m ≤ n
m≤pred[n]⇒m&lt;n     : m ≤ pred n → m &lt; n
m&lt;n⇒m≤pred[n]     : m &lt; n → m ≤ pred n
m≤m+n             : m ≤ m + + n
n≤m+n             : n ≤ + m + n
m-n≤m             : m - + n ≤ m

≤-&lt;-trans         : Trans _≤_ _&lt;_ _&lt;_
&lt;-≤-trans         : Trans _&lt;_ _≤_ _&lt;_
&gt;→≰               : x &gt; y → x ≰ y
&gt;-irrefl          : Irreflexive _≡_ _&gt;_

pos-+-commute     : Homomorphic₂ +_ ℕ._+_ _+_
neg-distribˡ-*    : - (x * y) ≡ (- x) * y
neg-distribʳ-*    : - (x * y) ≡ x * (- y)
*-distribˡ-+      : _*_ DistributesOverˡ _+_
≤-steps           : m ≤ n → m ≤ + p + n
≤-step-neg        : m ≤ n → pred m ≤ n
≤-steps-neg       : m ≤ n → m - + p ≤ n
m≡n⇒m-n≡0         : m ≡ n → m - n ≡ + 0
m-n≡0⇒m≡n         : m - n ≡ + 0 → m ≡ n
0≤n⇒+∣n∣≡n        : + 0 ≤ n → + ∣ n ∣ ≡ n
+∣n∣≡n⇒0≤n        : + ∣ n ∣ ≡ n → + 0 ≤ n
◃-≡               : sign m ≡ sign n → ∣ m ∣ ≡ ∣ n ∣ → m ≡ n

+-isMagma         : IsMagma _+_
*-isMagma         : IsMagma _*_
+-magma           : Magma 0ℓ 0ℓ
*-magma           : Magma 0ℓ 0ℓ
+-semigroup       : Semigroup 0ℓ 0ℓ
*-semigroup       : Semigroup 0ℓ 0ℓ
+-0-monoid        : Monoid 0ℓ 0ℓ
*-1-monoid        : Monoid 0ℓ 0ℓ
+-*-ring          : Ring 0ℓ 0ℓ

&lt;-isStrictPartialOrder : IsStrictPartialOrder _≡_ _&lt;_
&lt;-strictPartialOrder   : StrictPartialOrder _ _ _
</code></pre>
  </li>
  <li>Added new proofs to <code class="language-plaintext highlighter-rouge">Data.List.Categorical</code>:
    <pre><code class="language-agda">applicativeZero : RawApplicativeZero List
alternative     : RawAlternative List
</code></pre>
  </li>
  <li>Added new operations to <code class="language-plaintext highlighter-rouge">Data.List.Relation.Unary.All</code>:
    <pre><code class="language-agda">zipWith   : P ∩ Q ⊆ R → All P ∩ All Q ⊆ All R
unzipWith : R ⊆ P ∩ Q → All R ⊆ All P ∩ All Q

sequenceA : All (F ∘′ P) ⊆ F ∘′ All P
sequenceM : All (M ∘′ P) ⊆ M ∘′ All P
mapA      : (Q ⊆ F ∘′ P) → All Q ⊆ (F ∘′ All P)
mapM      : (Q ⊆ M ∘′ P) → All Q ⊆ (M ∘′ All P)
forA      : All Q xs → (Q ⊆ F ∘′ P) → F (All P xs)
forM      : All Q xs → (Q ⊆ M ∘′ P) → M (All P xs)

updateAt  : x ∈ xs → (P x → P x) → All P xs → All P xs
_[_]%=_   : All P xs → x ∈ xs → (P x → P x) → All P xs
_[_]≔_    : All P xs → x ∈ xs → P x → All P xs
</code></pre>
  </li>
  <li>Added new proofs to <code class="language-plaintext highlighter-rouge">Data.List.Relation.Unary.All.Properties</code>:
    <pre><code class="language-agda">respects    : P Respects _≈_ → (All P) Respects _≋_
─⁺          : All Q xs → All Q (xs Any.─ p)
─⁻          : Q (Any.lookup p) → All Q (xs Any.─ p) → All Q xs

map-cong    : f ≗ g → map f ps ≡ map g ps
map-id      : map id ps ≡ ps
map-compose : map g (map f ps) ≡ map (g ∘ f) ps
lookup-map  : lookup (map f ps) i ≡ f (lookup ps i)

∷ʳ⁺         : All P xs → P x → All P (xs ∷ʳ x)
∷ʳ⁻         : All P (xs ∷ʳ x) → All P xs × P x
</code></pre>
  </li>
  <li>Added new proofs to <code class="language-plaintext highlighter-rouge">Data.List.Relation.Binary.Equality.DecPropositional</code>:
    <pre><code class="language-agda">_≡?_        : Decidable (_≡_ {A = List A})
</code></pre>
  </li>
  <li>Added new functions to <code class="language-plaintext highlighter-rouge">Data.List.Relation.Unary.Any</code>:
    <pre><code class="language-agda">lookup : Any P xs → A
_∷=_   : Any P xs → A → List A
_─_    : ∀ xs → Any P xs → List A
</code></pre>
  </li>
  <li>Added new functions to <code class="language-plaintext highlighter-rouge">Data.List.Base</code>:
    <pre><code class="language-agda">intercalate       : List A → List (List A) → List A
partitionSumsWith : (A → B ⊎ C) → List A → List B × List C
partitionSums     : List (A ⊎ B) → List A × List B

_[_]%=_           : (xs : List A) → Fin (length xs) → (A → A) → List A
_[_]∷=_           : (xs : List A) → Fin (length xs) → A → List A
_─_               : (xs : List A) → Fin (length xs) → List A

reverseAcc        : List A → List A → List A
</code></pre>
  </li>
  <li>Added new proofs to <code class="language-plaintext highlighter-rouge">Data.List.Membership.Propositional.Properties</code>:
    <pre><code class="language-agda">∈-allFin : (k : Fin n) → k ∈ allFin n
[]∈inits : [] ∈ inits as
</code></pre>
  </li>
  <li>Added new function to <code class="language-plaintext highlighter-rouge">Data.List.Membership.(Setoid/Propositional)</code>:
    <pre><code class="language-agda">_∷=_ : x ∈ xs → A → List A
_─_  : (xs : List A) → x ∈ xs → List A
</code></pre>
    <p>Added laws for <code class="language-plaintext highlighter-rouge">updateAt</code>. The laws that previously existed for <code class="language-plaintext highlighter-rouge">_[_]≔_</code> are now
special instances of these.</p>
  </li>
  <li>Added new proofs to <code class="language-plaintext highlighter-rouge">Data.List.Membership.Setoid.Properties</code>:
    <pre><code class="language-agda">length-mapWith∈ : length (mapWith∈ xs f) ≡ length xs

∈-∷=⁺-updated   : v ∈ (x∈xs ∷= v)
∈-∷=⁺-untouched : x ≉ y → y ∈ xs → y ∈ (x∈xs ∷= v)
∈-∷=⁻           : y ≉ v → y ∈ (x∈xs ∷= v) → y ∈ xs

map-∷=          : map f (x∈xs ∷= v) ≡ ∈-map⁺ f≈ pr ∷= f v
</code></pre>
  </li>
  <li>Added new proofs to <code class="language-plaintext highlighter-rouge">Data.List.Properties</code>:
    <pre><code class="language-agda">≡-dec                : Decidable _≡_ → Decidable {A = List A} _≡_

++-cancelˡ           : xs ++ ys ≡ xs ++ zs → ys ≡ zs
++-cancelʳ           : ys ++ xs ≡ zs ++ xs → ys ≡ zs
++-cancel            : Cancellative _++_
++-conicalˡ          : xs ++ ys ≡ [] → xs ≡ []
++-conicalʳ          : xs ++ ys ≡ [] → ys ≡ []
++-conical           : Conical [] _++_
++-isMagma           : IsMagma _++_

length-%=            : length (xs [ k ]%= f) ≡ length xs
length-∷=            : length (xs [ k ]∷= v) ≡ length xs
length-─             : length (xs ─ k) ≡ pred (length xs)
map-∷=               : map f (xs [ k ]∷= v) ≡ map f xs [ cast eq k ]∷= f v
map-─                : map f (xs ─ k) ≡ map f xs ─ cast eq k

length-applyUpTo     : length (applyUpTo     f n) ≡ n
length-applyDownFrom : length (applyDownFrom f n) ≡ n
length-upTo          : length (upTo            n) ≡ n
length-downFrom      : length (downFrom        n) ≡ n
length-tabulate      : length (tabulate      f  ) ≡ n

lookup-applyUpTo     : lookup (applyUpTo     f n) i ≡ f (toℕ i)
lookup-applyDownFrom : lookup (applyDownFrom f n) i ≡ f (n ∸ (suc (toℕ i)))
lookup-upTo          : lookup (upTo            n) i ≡ toℕ i
lookup-downFrom      : lookup (downFrom        n) i ≡ n ∸ (suc (toℕ i))
lookup-tabulate      : lookup (tabulate      f)  i′ ≡ f i

map-tabulate         : map f (tabulate g) ≡ tabulate (f ∘ g)
</code></pre>
  </li>
  <li>Added new proofs to <code class="language-plaintext highlighter-rouge">Data.List.Relation.Binary.Permutation.Inductive.Properties</code>:
    <pre><code class="language-agda">++-isMagma : IsMagma _↭_ _++_
++-magma   : Magma _ _
</code></pre>
  </li>
  <li>Added new proofs to <code class="language-plaintext highlighter-rouge">Data.List.Relation.Binary.Pointwise</code>:
    <pre><code class="language-agda">reverseAcc⁺ : Pointwise R a x → Pointwise R b y → Pointwise R (reverseAcc a b) (reverseAcc x y)
reverse⁺    : Pointwise R as bs → Pointwise R (reverse as) (reverse bs)
map⁺        : Pointwise (λ a b → R (f a) (g b)) as bs → Pointwise R (map f as) (map g bs)
map⁻        : Pointwise R (map f as) (map g bs) → Pointwise (λ a b → R (f a) (g b)) as bs
filter⁺     : Pointwise R as bs → Pointwise R (filter P? as) (filter Q? bs)
replicate⁺  : R a b → Pointwise R (replicate n a) (replicate n b)
irrelevant  : Irrelevant R → Irrelevant (Pointwise R)
</code></pre>
  </li>
  <li>Added new function to <code class="language-plaintext highlighter-rouge">Data.Maybe.Base</code>:
    <pre><code class="language-agda">_&lt;∣&gt;_     : Maybe A → Maybe A → Maybe A
</code></pre>
  </li>
  <li>Added new proofs to <code class="language-plaintext highlighter-rouge">Data.Maybe.Categorical</code>:
    <pre><code class="language-agda">applicativeZero : RawApplicativeZero Maybe
alternative     : RawAlternative Maybe
</code></pre>
  </li>
  <li>Added new proof to <code class="language-plaintext highlighter-rouge">Data.Maybe.Properties</code>:
    <pre><code class="language-agda">≡-dec : Decidable _≡_ → Decidable {A = Maybe A} _≡_
</code></pre>
  </li>
  <li>Added new proof to <code class="language-plaintext highlighter-rouge">Data.Maybe.Relation.Binary.Pointwise</code>:
    <pre><code class="language-agda">reflexive : _≡_ ⇒ R → _≡_ ⇒ Pointwise R
</code></pre>
  </li>
  <li>Added new proofs to <code class="language-plaintext highlighter-rouge">Data.Maybe.Relation.Unary.All</code>:
    <pre><code class="language-agda">drop-just        : All P (just x) → P x
just-equivalence : P x ⇔ All P (just x)
map              : P ⊆ Q → All P ⊆ All Q
fromAny          : Any P ⊆ All P
zipWith          : P ∩ Q ⊆ R → All P ∩ All Q ⊆ All R
unzipWith        : P ⊆ Q ∩ R → All P ⊆ All Q ∩ All R
zip              : All P ∩ All Q ⊆ All (P ∩ Q)
unzip            : All (P ∩ Q) ⊆ All P ∩ All Q
sequenceA        : RawApplicative F → All (F ∘′ P) ⊆ F ∘′ All P
mapA             : RawApplicative F → (Q ⊆ F ∘′ P) → All Q ⊆ (F ∘′ All P)
forA             : RawApplicative F → All Q xs → (Q ⊆ F ∘′ P) → F (All P xs)
sequenceM        : RawMonad M → All (M ∘′ P) ⊆ M ∘′ All P
mapM             : RawMonad M → (Q ⊆ M ∘′ P) → All Q ⊆ (M ∘′ All P)
forM             : RawMonad M → All Q xs → (Q ⊆ M ∘′ P) → M (All P xs)
universal        : Universal P → Universal (All P)
irrelevant       : Irrelevant P → Irrelevant (All P)
satisfiable      : Satisfiable (All P)
</code></pre>
  </li>
  <li>Added new proofs to <code class="language-plaintext highlighter-rouge">Data.Maybe.Relation.Unary.Any</code>:
    <pre><code class="language-agda">drop-just        : Any P (just x) → P x
just-equivalence : P x ⇔ Any P (just x)
map              : P ⊆ Q → Any P ⊆ Any Q
satisfied        : Any P x → ∃ P
zipWith          : P ∩ Q ⊆ R → Any P ∩ Any Q ⊆ Any R
unzipWith        : P ⊆ Q ∩ R → Any P ⊆ Any Q ∩ Any R
zip              : Any P ∩ Any Q ⊆ Any (P ∩ Q)
unzip            : Any (P ∩ Q) ⊆ Any P ∩ Any Q
irrelevant       : Irrelevant P → Irrelevant (Any P)
satisfiable      : Satisfiable P → Satisfiable (Any P)
</code></pre>
  </li>
  <li>Added a third alternative definition of “less than” to <code class="language-plaintext highlighter-rouge">Data.Nat.Base</code>:
    <pre><code class="language-agda">_≤‴_ : Rel ℕ 0ℓ
_&lt;‴_ : Rel ℕ 0ℓ
_≥‴_ : Rel ℕ 0ℓ
_&gt;‴_ : Rel ℕ 0ℓ
</code></pre>
  </li>
  <li>Added new proofs to <code class="language-plaintext highlighter-rouge">Data.Nat.Properties</code>:
    <pre><code class="language-agda">+-isMagma          : IsMagma _+_
*-isMagma          : IsMagma _*_
⊔-isMagma          : IsMagma _⊔_
⊓-isMagma          : IsMagma _⊓_
⊔-isBand           : IsBand _⊔_
⊓-isBand           : IsBand _⊓_
⊔-isSemilattice    : IsSemilattice _⊔_
⊓-isSemilattice    : IsSemilattice _⊓_

+-magma            : Magma 0ℓ 0ℓ
*-magma            : Magma 0ℓ 0ℓ
⊔-magma            : Magma 0ℓ 0ℓ
⊓-magma            : Magma 0ℓ 0ℓ
⊔-band             : Band 0ℓ 0ℓ
⊓-band             : Band 0ℓ 0ℓ
⊔-semilattice      : Semilattice 0ℓ 0ℓ
⊓-semilattice      : Semilattice 0ℓ 0ℓ

+-cancelˡ-&lt;        : LeftCancellative _&lt;_ _+_
+-cancelʳ-&lt;        : RightCancellative _&lt;_ _+_
+-cancel-&lt;         : Cancellative _&lt;_ _+_

m≤n⇒m⊓o≤n          : m ≤ n → m ⊓ o ≤ n
m≤n⇒o⊓m≤n          : m ≤ n → o ⊓ m ≤ n
m&lt;n⇒m⊓o&lt;n          : m &lt; n → m ⊓ o &lt; n
m&lt;n⇒o⊓m&lt;n          : m &lt; n → o ⊓ m &lt; n
m≤n⊓o⇒m≤n          : m ≤ n ⊓ o → m ≤ n
m≤n⊓o⇒m≤o          : m ≤ n ⊓ o → m ≤ o
m&lt;n⊓o⇒m&lt;n          : m &lt; n ⊓ o → m &lt; n
m&lt;n⊓o⇒m&lt;o          : m &lt; n ⊓ o → m &lt; o
m≤n⇒m≤n⊔o          : m ≤ n → m ≤ n ⊔ o
m≤n⇒m≤o⊔n          : m ≤ n → m ≤ o ⊔ n
m&lt;n⇒m&lt;n⊔o          : m &lt; n → m &lt; n ⊔ o
m&lt;n⇒m&lt;o⊔n          : m &lt; n → m &lt; o ⊔ n
m⊔n≤o⇒m≤o          : m ⊔ n ≤ o → m ≤ o
m⊔n≤o⇒n≤o          : m ⊔ n ≤ o → n ≤ o
m⊔n&lt;o⇒m&lt;o          : m ⊔ n &lt; o → m &lt; o
m⊔n&lt;o⇒n&lt;o          : m ⊔ n &lt; o → n &lt; o

m≢0⇒suc[pred[m]]≡m : m ≢ 0 → suc (pred m) ≡ m
m≢1+n+m            : m ≢ suc (n + m)

≡ᵇ⇒≡               : T (m ≡ᵇ n) → m ≡ n
≡⇒≡ᵇ               : m ≡ n → T (m ≡ᵇ n)
≡-irrelevant       : Irrelevant {A = ℕ} _≡_
≟-diag             : (eq : m ≡ n) → (m ≟ n) ≡ yes eq

≤′-trans           : Transitive _≤′_

m&lt;ᵇn⇒1+m+[n-1+m]≡n : T (m &lt;ᵇ n) → suc m + (n ∸ suc m) ≡ n
m&lt;ᵇ1+m+n           : T (m &lt;ᵇ suc (m + n))

&lt;ᵇ⇒&lt;″              : T (m &lt;ᵇ n) → m &lt;″ n
&lt;″⇒&lt;ᵇ              : m &lt;″ n → T (m &lt;ᵇ n)
≤‴⇒≤″              : ∀{m n} → m ≤‴ n → m ≤″ n
≤″⇒≤‴              : ∀{m n} → m ≤″ n → m ≤‴ n

≤″-irrelevant      : Irrelevant _≤″_
≥″-irrelevant      : Irrelevant _≥″_
&lt;″-irrelevant      : Irrelevant _&lt;″_
&gt;″-irrelevant      : Irrelevant _&gt;″_

m≤‴m+k             : m + k ≡ n → m ≤‴ n
</code></pre>
  </li>
  <li>Added new proof to <code class="language-plaintext highlighter-rouge">Data.Product.Properties.WithK</code>:
    <pre><code class="language-agda">,-injective : (a , b) ≡ (c , d) → a ≡ c × b ≡ d
≡-dec       : Decidable _≡_ → (∀ {a} → Decidable {A = B a} _≡_) → Decidable {A = Σ A B} _≡_
</code></pre>
  </li>
  <li>Added new functions to <code class="language-plaintext highlighter-rouge">Data.Product.Relation.Binary.Pointwise.NonDependent</code>:
    <pre><code class="language-agda">&lt;_,_&gt;ₛ : A ⟶ B → A ⟶ C → A ⟶ (B ×ₛ C)
proj₁ₛ : (A ×ₛ B) ⟶ A
proj₂ₛ : (A ×ₛ B) ⟶ B
swapₛ  : (A ×ₛ B) ⟶ (B ×ₛ A)
</code></pre>
  </li>
  <li>Added new functions to <code class="language-plaintext highlighter-rouge">Data.Rational</code>:
    <pre><code class="language-agda">-_       : ℚ → ℚ
1/_      : (p : ℚ) → .{n≢0 : ∣ ℚ.numerator p ∣ ≢0} → ℚ
_*_      : ℚ → ℚ → ℚ
_+_      : ℚ → ℚ → ℚ
_-_      : ℚ → ℚ → ℚ
_/_      : (p₁ p₂ : ℚ) → {n≢0 : ∣ ℚ.numerator p₂ ∣ ≢0} → ℚ
show     : ℚ → String
</code></pre>
  </li>
  <li>Added new proofs to <code class="language-plaintext highlighter-rouge">Data.Sign.Properties</code>:
    <pre><code class="language-agda">*-isMagma : IsMagma _*_
*-magma   : Magma 0ℓ 0ℓ
</code></pre>
  </li>
  <li>Added new functions to <code class="language-plaintext highlighter-rouge">Data.Sum.Base</code>:
    <pre><code class="language-agda">fromDec : Dec P → P ⊎ ¬ P
toDec   : P ⊎ ¬ P → Dec P
</code></pre>
  </li>
  <li>Added new proof to <code class="language-plaintext highlighter-rouge">Data.Sum.Properties</code>:
    <pre><code class="language-agda">≡-dec : Decidable _≡_ → Decidable _≡_ → Decidable {A = A ⊎ B} _≡_
</code></pre>
  </li>
  <li>Added new functions to <code class="language-plaintext highlighter-rouge">Data.Sum.Relation.Binary.Pointwise</code>:
    <pre><code class="language-agda">inj₁ₛ  : A ⟶ (A ⊎ₛ B)
inj₂ₛ  : B ⟶ (A ⊎ₛ B)
[_,_]ₛ : (A ⟶ C) → (B ⟶ C) → (A ⊎ₛ B) ⟶ C
swapₛ  : (A ⊎ₛ B) ⟶ (B ⊎ₛ A)
</code></pre>
  </li>
  <li>Added new function to <code class="language-plaintext highlighter-rouge">Data.These</code>:
    <pre><code class="language-agda">fromSum : A ⊎ B → These A B
</code></pre>
  </li>
  <li>Added to <code class="language-plaintext highlighter-rouge">Data.Vec</code> a generalization of single point overwrite <code class="language-plaintext highlighter-rouge">_[_]≔_</code> to
single-point modification <code class="language-plaintext highlighter-rouge">_[_]%=_</code> (with an alias <code class="language-plaintext highlighter-rouge">updateAt</code> with different
argument order):
    <pre><code class="language-agda">_[_]%=_   : Vec A n → Fin n → (A → A) → Vec A n
updateAt  : Fin n → (A → A) → Vec A n → Vec A n
</code></pre>
  </li>
  <li>
    <p>Added proofs for <code class="language-plaintext highlighter-rouge">updateAt</code> to <code class="language-plaintext highlighter-rouge">Data.Vec.Properties</code>. Previously existing proofs for
<code class="language-plaintext highlighter-rouge">_[_]≔_</code> are now special instances of these.</p>
  </li>
  <li>Added new proofs to <code class="language-plaintext highlighter-rouge">Data.Vec.Relation.Unary.Any.Properties</code>:
    <pre><code class="language-agda">lookup-index          : (p : Any P xs) → P (lookup (index p) xs)

lift-resp             : P Respects _≈_ → (Any P) Respects (Pointwise _≈_)
here-injective        : here p ≡ here q → p ≡ q
there-injective       : there p ≡ there q → p ≡ q

¬Any[]                : ¬ Any P []
⊥↔Any⊥                : ⊥ ↔ Any (const ⊥) xs
⊥↔Any[]               : ⊥ ↔ Any P []

map-id                : ∀ f → (∀ p → f p ≡ p) → ∀ p → Any.map f p ≡ p
map-∘                 : Any.map (f ∘ g) p ≡ Any.map f (Any.map g p)

swap                  : Any (λ x → Any (x ∼_) ys) xs → Any (λ y → Any (_∼ y) xs) ys
swap-there            : swap (Any.map there p) ≡ there (swap p)
swap-invol            : swap (swap p) ≡ p
swap↔                 : Any (λ x → Any (x ∼_) ys) xs ↔ Any (λ y → Any (_∼ y) xs) ys

Any-⊎⁺                : Any P xs ⊎ Any Q xs → Any (λ x → P x ⊎ Q x) xs
Any-⊎⁻                : Any (λ x → P x ⊎ Q x) xs → Any P xs ⊎ Any Q xs
⊎↔                    : (Any P xs ⊎ Any Q xs) ↔ Any (λ x → P x ⊎ Q x) xs

Any-×⁺                : Any P xs × Any Q ys → Any (λ x → Any (λ y → P x × Q y) ys) xs
Any-×⁻                : Any (λ x → Any (λ y → P x × Q y) ys) xs → Any P xs × Any Q ys

singleton⁺            : P x → Any P [ x ]
singleton⁻            : Any P [ x ] → P x
singleton⁺∘singleton⁻ : singleton⁺ (singleton⁻ p) ≡ p
singleton⁻∘singleton⁺ : singleton⁻ (singleton⁺ p) ≡ p
singleton↔            : P x ↔ Any P [ x ]

map⁺                  : Any (P ∘ f) xs → Any P (map f xs)
map⁻                  : Any P (map f xs) → Any (P ∘ f) xs
map⁺∘map⁻             : map⁺ (map⁻ p) ≡ p
map⁻∘map⁺             : map⁻ (map⁺ p) ≡ p
map↔                  : Any (P ∘ f) xs ↔ Any P (map f xs)

++⁺ˡ                  : Any P xs → Any P (xs ++ ys)
++⁺ʳ                  : Any P ys → Any P (xs ++ ys)
++⁻                   : Any P (xs ++ ys) → Any P xs ⊎ Any P ys
++⁺∘++⁻               : ∀ p → [ ++⁺ˡ , ++⁺ʳ xs ]′ (++⁻ xs p) ≡ p
++⁻∘++⁺               : ∀ p → ++⁻ xs ([ ++⁺ˡ , ++⁺ʳ xs ]′ p) ≡ p
++-comm               : ∀ xs ys → Any P (xs ++ ys) → Any P (ys ++ xs)
++-comm∘++-comm       : ∀ p → ++-comm ys xs (++-comm xs ys p) ≡ p
++-insert             : ∀ xs → P x → Any P (xs ++ [ x ] ++ ys)
++↔                   : (Any P xs ⊎ Any P ys) ↔ Any P (xs ++ ys)
++↔++                 : ∀ xs ys → Any P (xs ++ ys) ↔ Any P (ys ++ xs)

concat⁺               : Any (Any P) xss → Any P (concat xss)
concat⁻               : Any P (concat xss) → Any (Any P) xss
concat⁻∘++⁺ˡ          : ∀ xss p → concat⁻ (xs ∷ xss) (++⁺ˡ p) ≡ here p
concat⁻∘++⁺ʳ          : ∀ xs xss p → concat⁻ (xs ∷ xss) (++⁺ʳ xs p) ≡ there (concat⁻ xss p)
concat⁺∘concat⁻       : ∀ xss p → concat⁺ (concat⁻ xss p) ≡ p
concat⁻∘concat⁺       : ∀ p → concat⁻ xss (concat⁺ p) ≡ p
concat↔               : Any (Any P) xss ↔ Any P (concat xss)

tabulate⁺             : ∀ i → P (f i) → Any P (tabulate f)
tabulate⁻             : Any P (tabulate f) → ∃ λ i → P (f i)

mapWith∈⁺             : ∀ f → (∃₂ λ x p → P (f p)) → Any P (mapWith∈ xs f)
mapWith∈⁻             : ∀ xs f → Any P (mapWith∈ xs f) → ∃₂ λ x p → P (f p)
mapWith∈↔             : (∃₂ λ x p → P (f p)) ↔ Any P (mapWith∈ xs f)

toList⁺               : Any P xs → List.Any P (toList xs)
toList⁻               : List.Any P (toList xs) → Any P xs
fromList⁺             : List.Any P xs → Any P (fromList xs)
fromList⁻             : Any P (fromList xs) → List.Any P xs

∷↔                    : ∀ P → (P x ⊎ Any P xs) ↔ Any P (x ∷ xs)
&gt;&gt;=↔                  : Any (Any P ∘ f) xs ↔ Any P (xs &gt;&gt;= f)
</code></pre>
  </li>
  <li>Added new functions to <code class="language-plaintext highlighter-rouge">Data.Vec.Membership.Propositional.Properties</code>:
    <pre><code class="language-agda">fromAny : Any P xs → ∃ λ x → x ∈ xs × P x
toAny   : x ∈ xs → P x → Any P xs
</code></pre>
  </li>
  <li>Added new proof to <code class="language-plaintext highlighter-rouge">Data.Vec.Properties</code>:
    <pre><code class="language-agda">≡-dec : Decidable _≡_ → ∀ {n} → Decidable {A = Vec A n} _≡_
</code></pre>
  </li>
  <li>Added new proofs to <code class="language-plaintext highlighter-rouge">Function.Related.TypeIsomorphisms</code>:
    <pre><code class="language-agda">×-isMagma : ∀ k ℓ → IsMagma (Related ⌊ k ⌋) _×_
⊎-isMagma : ∀ k ℓ → IsMagma (Related ⌊ k ⌋) _⊎_

×-magma   : Symmetric-kind → (ℓ : Level) → Magma _ _
⊎-magma   : Symmetric-kind → (ℓ : Level) → Semigroup _ _
</code></pre>
  </li>
  <li>Added new proofs to <code class="language-plaintext highlighter-rouge">Relation.Binary.Consequences</code>:
    <pre><code class="language-agda">wlog : Total _R_ → Symmetric Q → (∀ a b → a R b → Q a b) → ∀ a b → Q a b
</code></pre>
  </li>
  <li>Added new definitions to <code class="language-plaintext highlighter-rouge">Relation.Binary.Core</code>:
    <pre><code class="language-agda">Antisym R S E = ∀ {i j} → R i j → S j i → E i j

Max : REL A B ℓ → B → Set _
Min : REL A B ℓ → A → Set _

Conn P Q = ∀ x y → P x y ⊎ Q y x

P ⟶ Q Respects _∼_ = ∀ {x y} → x ∼ y → P x → Q y
</code></pre>
    <p>Additionally the definition of the types <code class="language-plaintext highlighter-rouge">_Respectsʳ_</code>/<code class="language-plaintext highlighter-rouge">_Respectsˡ_</code> has been
generalised as follows in order to support heterogenous relations:</p>
    <pre><code class="language-agda">_Respectsʳ_ : REL A B ℓ₁ → Rel B ℓ₂ → Set _
_Respectsˡ_ : REL A B ℓ₁ → Rel A ℓ₂ → Set _
</code></pre>
  </li>
  <li>Added new proofs to <code class="language-plaintext highlighter-rouge">Relation.Binary.Lattice</code>:
    <pre><code class="language-agda">Lattice.setoid        : Setoid c ℓ
BoundedLattice.setoid : Setoid c ℓ
</code></pre>
  </li>
  <li>Added new operations and proofs to <code class="language-plaintext highlighter-rouge">Relation.Binary.Properties.HeytingAlgebra</code>:
    <pre><code class="language-agda">y≤x⇨y            : y ≤ x ⇨ y
⇨-unit           : x ⇨ x ≈ ⊤
⇨-drop           : (x ⇨ y) ∧ y ≈ y
⇨-app            : (x ⇨ y) ∧ x ≈ y ∧ x
⇨-relax          : _⇨_ Preserves₂ (flip _≤_) ⟶ _≤_ ⟶ _≤_
⇨-cong           : _⇨_ Preserves₂ _≈_ ⟶ _≈_ ⟶ _≈_
⇨-applyˡ         : w ≤ x → (x ⇨ y) ∧ w ≤ y
⇨-applyʳ         : w ≤ x → w ∧ (x ⇨ y) ≤ y
⇨-curry          : x ∧ y ⇨ z ≈ x ⇨ y ⇨ z
⇨ʳ-covariant     : (x ⇨_) Preserves _≤_ ⟶ _≤_
⇨ˡ-contravariant : (_⇨ x) Preserves (flip _≤_) ⟶ _≤_

¬_               : Op₁ Carrier
x≤¬¬x            : x ≤ ¬ ¬ x
de-morgan₁       : ¬ (x ∨ y) ≈ ¬ x ∧ ¬ y
de-morgan₂-≤     : ¬ (x ∧ y) ≤ ¬ ¬ (¬ x ∨ ¬ y)
de-morgan₂-≥     : ¬ ¬ (¬ x ∨ ¬ y) ≤ ¬ (x ∧ y)
de-morgan₂       : ¬ (x ∧ y) ≈ ¬ ¬ (¬ x ∨ ¬ y)
weak-lem         : ¬ ¬ (¬ x ∨ x) ≈ ⊤
</code></pre>
  </li>
  <li>Added new proofs to <code class="language-plaintext highlighter-rouge">Relation.Binary.Properties.JoinSemilattice</code>:
    <pre><code class="language-agda">x≤y⇒x∨y≈y : x ≤ y → x ∨ y ≈ y
</code></pre>
  </li>
  <li>Added new proofs to <code class="language-plaintext highlighter-rouge">Relation.Binary.Properties.Lattice</code>:
    <pre><code class="language-agda">∧≤∨            : x ∧ y ≤ x ∨ y
quadrilateral₁ : x ∨ y ≈ x → x ∧ y ≈ y
quadrilateral₂ : x ∧ y ≈ y → x ∨ y ≈ x
collapse₁      : x ≈ y → x ∧ y ≈ x ∨ y
collapse₂      : x ∨ y ≤ x ∧ y → x ≈ y
</code></pre>
  </li>
  <li>Added new proofs to <code class="language-plaintext highlighter-rouge">Relation.Binary.Properties.MeetSemilattice</code>:
    <pre><code class="language-agda">y≤x⇒x∧y≈y : y ≤ x → x ∧ y ≈ y
</code></pre>
  </li>
  <li>Added new definitions to <code class="language-plaintext highlighter-rouge">Relation.Binary.PropositionalEquality</code>:
    <pre><code class="language-agda">trans-injectiveˡ  : trans p₁ q ≡ trans p₂ q → p₁ ≡ p₂
trans-injectiveʳ  : trans p q₁ ≡ trans p q₂ → q₁ ≡ q₂
subst-injective   : subst P x≡y p ≡ subst P x≡y q → p ≡ q
cong-id           : cong id p ≡ p
cong-∘            : cong (f ∘ g) p ≡ cong f (cong g p)
cong-≡id          : (f≡id : ∀ x → f x ≡ x) → cong f (f≡id x) ≡ f≡id (f x)
naturality        : trans (cong f x≡y) (f≡g y) ≡ trans (f≡g x) (cong g x≡y)
subst-application : (eq : x₁ ≡ x₂) → subst B₂ eq (g x₁ y) ≡ g x₂ (subst B₁ (cong f eq) y)
subst-subst       : subst P y≡z (subst P x≡y p) ≡ subst P (trans x≡y y≡z) p
subst-subst-sym   : subst P x≡y (subst P (sym x≡y) p) ≡ p
subst-sym-subst   : subst P (sym x≡y) (subst P x≡y p) ≡ p
subst-∘           : subst (P ∘ f) x≡y p ≡ subst P (cong f x≡y) p
trans-assoc       : trans (trans p q) r ≡ trans p (trans q r)
trans-reflʳ       : trans p refl ≡ p
trans-symʳ        : trans p (sym p) ≡ refl
trans-symˡ        : trans (sym p) p ≡ refl
</code></pre>
  </li>
</ul>

</article>
    </main>

    <footer id="footer">
      <nav>
        <a href="/">Back to index.</a>
        <a href="#header">Back to top.</a>
      </nav>
      <div id="intro">This is where i jot down stuff. I am</div>
      <div class="bcard">
        <div class="bcard__photo"></div>
        <div class="bcard__brand">Paolo Brasolin</div>
        <div class="bcard__pitch">Software engineer</div>
        <div class="bcard__links">
          <a href="mailto:paolobrasolin@gmail.com">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-mail"><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path><polyline points="22,6 12,13 2,6"></polyline></svg>
          </a>
          <a href="https://github.com/paolobrasolin/">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg>
          </a>
          <a href="https://twitter.com/paolobrasolin">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-twitter"><path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path></svg>
          </a>
          <a href="https://www.linkedin.com/in/paolobrasolin/">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-linkedin"><path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z"></path><rect x="2" y="9" width="4" height="12"></rect><circle cx="4" cy="4" r="2"></circle></svg>
          </a>
        </div>
      </div>
      <div id="glyph">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 8 12">
          <path fill="none" stroke-linejoin="bevel" stroke-width="1" d="M1 7h6v-6h-6v4h4v-2h-2v8h-2v-2h4"/>
        </svg>
      </div>
    </footer>
  </body>
</html>
